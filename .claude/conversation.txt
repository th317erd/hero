So this is what we are going to do now. We are going to have "processes" which we will load, and these will be instructions for whatever AI agent to follow. In the dialog for a new/edit agent, a user can select which "processes" they want any given agent to have by default. There can also be user created "processes" that are stored in the database. This will be added/edited on a new dialog for adding a "process", which is just a named, stored message or instruction for the AI agent. All "process" markdown files from inside the source code of the server will be prefixed with "system_" and loaded into memory. These "processes" are then injected in whenever they are referenced. This referencing can be dynamic, because it is part of the instruction set. For example !!SYSTEM_ACT!! would inject the ACTION (defined as instructions previously to the AI) to "operate" or "act".

When this happens, the AI will return
```json
```
syntax. This is an "Action" or an "operation". If it (trimmed) starts with exactly "```json", and ends with exactly "```", and it is a parsable JSON blob that doesn't throw exceptions, and it is parsed with JSON.load (NOT!!! "exec"). This is where WE take over with the internal "process" system in memory, and the "user" process system loading from the database, and also execute whatever is in the JSON object. For example, look at the server/lib/processes/act.md "process" telling the AI how to behave.

Does this make sense? All messages get intercepted and put through out plugin system. By default they go through a "message" method. However, if a "```json...```" response was matched, then we would call the internal/plugin system for "opteration", with an already validated and parsed JSON object, that is essentially an array of commands to execute. In the future we will expand with new "functions", such as "bash" (run executables on the local system), "read" (read a file), etc...

Does this make sense? So we need an internal "processes" engine that loads the files out of the directory of the same name, prefixes all those names with "system_" (so as not to collide with user space). Then, when we get an "opperation" command in the JSON, we will see the function might be something like "[ { "command": "system_act", message:  ]